메모리: 29124KB<br>
시간: 316ms

# 풀이
## 접근
1. 포도주 잔을 선택하면 잔 안에 있는 모든 포도주를 마셔야 하고 잔은 원래 위치로
2. 연속으로 놓인 3잔을 모두 마실 순 없음
3. 효주가 최대한 많은 양의 포도주를 마실 수 있도록 하기

#### 테이블 정의
dp[i]=i번째에서 최대로 마실 수 있는 포도주의 양

#### 점화식
연속으로 놓인 3잔을 모두 마실 순 없으므로
- 

dp[i]=dp[i-2]+drink[i]
- 한 번 건너뛰고 바로 마신 경우<br>
i-2를 마시면 3연속이므로 i-3부터 시작해 i-2 스킵

dp[i]=dp[i-3]+drink[i-1]+drink[i]

max를 찾아서 dp[i]에 넣으면 된다.

#### 초기화
dp[1]=drink[1]
dp[2]=drink[1]+drink[2]
dp[3]=Math.max(drink[1],drink[2])+drink[3]

## 문제점
근데 그렇게 계획하고 풀었더니 틀렸다고 한다.

#### 뭐가 문제인가?
가능한 경우의 수가 더 있다고 한다.
1. 현재 잔을 마시지 않은 경우 `dp[i-1]`
2. 현재 잔을 마시고, 이전 잔을 마시지 않은 경우 `dp[i-2]+drink[i]`
3. 현재 잔과 이전 잔을 마시고, 이전이전 잔을 마시지 않은 경우 `dp[i-3]+drink[i-1]+drink[i]`

계단 오르기와 비슷한데 왜 점화식이 다른가?<br>
- 계단 오르기는 i번째 계단을 무조건 밟는 상황을 고려해 점수를 올린다.
- 포도주 시식은 i번째 잔을 안 마시고 넘어갈 수도 있다.

3연속 마시기 금지 규칙에 안 걸리나?<br>
3연속 중에서 한 잔을 스킵하는 3가지 경우를 바탕으로 만들어졌기 때문에 언제 적용해도 작동한다.

#### 그러고 나서 고치는데...
또 틀렸댄다. 알고보니 dp[3]에서 초기화할 때 값을 잘못 넣었다. (i번째를 스킵하는 경우를 안 썼다...)<br>
`dp[3]=Math.max(drink[1]+drink[2],Math.max(drink[1],drink[2])+drink[3])`으로 하니 정답.

# 코드
```java
import java.util.*;

public class Main {

	public static void main(String args[]) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt(); //포도주 잔 수
		int[] drink=new int[n+1];
		drink[0]=0;
		for(int i=1;i<=n;i++){
			drink[i]=sc.nextInt();
		}

		//테이블 정의, 초기화
		int[] dp=new int[n+1];
		if(n>=1) dp[1]=drink[1];
		if(n>=2) dp[2]=drink[1]+drink[2];
		if(n>=3) dp[3]=Math.max(drink[1]+drink[2],Math.max(drink[1],drink[2])+drink[3]);

		//점화식 기반의 반복문
		for(int i=4;i<=n;i++){
			dp[i]=Math.max(dp[i-1],Math.max(dp[i-2],dp[i-3]+drink[i-1])+drink[i]);
		}
		System.out.println(dp[n]);
	}
}

```