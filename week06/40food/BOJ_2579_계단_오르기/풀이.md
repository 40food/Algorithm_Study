메모리: 18008KB<br>
시간: 192ms

# 풀이

## 접근
1. 계단은 한 번에 한 계단 혹은 두 계단
2. 연속된 세 개의 계단을 모두 밟으면 안 됨(시작점 제외)
3. 마지막 계단은 반드시 밟아야 함

#### 1. 테이블 정의하기
dp[i]=i번째 계단까지 올라왔을 때 최대 점수

#### 2. 점화식 세우기<이게 정말 어려워서 보고함
연속 3개를 밟을 수 없기 때문에 i번째 계단에 올 수 있는 경우는 두 가지 뿐
1. (i-2)번째 계딴에서 한 번에 2칸 올라온 경우

    dp[i-2]+stairs[i]
2. (i-3)에서 (i-1)로 점프하고 1칸 올라온 경우<br>
i-3에서 i-2, i-1로 1칸씩 오면 i에 도착할 땐 3연속이다.

    dp[i-3]+stairs[i-1]+stairs[i]

둘 중 max인 걸 택하여 배열에 넣으면 된다.

#### 3. 초기값 정하기
맨 처음 세 계단은 초기값을 따로 처리해야 한다.

- dp[1]=stairs[1]
- dp[2]=stairs[1]+stairs[2]
- dp[3]=Math.max(stairs[1], stairs[2])+stairs[3]
    - Math.max(dp[3-2], dp[3-3]+stiars[3-1])+stairs[3]

이를 바탕으로 코드를 짠다.

## 문제점
- 주어지는 n은 300 이하의 자연수라고 했을 뿐, 최소값을 지정하진 않았다. 이를 생각 못 해 n이 1, 2, 3 이하일 때를 생각하지 않고 코드를 짜 실패했다.

# 코드
```java
import java.util.*;

public class Main {

	public static void main(String args[]) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt(); //계단 수
		int[] stairs=new int[n+1];
		stairs[0]=0;
		for(int i=1;i<=n;i++){
			stairs[i]=sc.nextInt();
		}

		// 테이블 정의, 초기값
		int[] dp=new int[n+1];

		if(n>=1) dp[1]=stairs[1];
		if(n>=2) dp[2]=stairs[1]+stairs[2];
		if(n>=3) dp[3]=Math.max(stairs[1],stairs[2])+stairs[3];

		// 점화식 기반의 반복문
		// n이 3 이하면 처음부터 조건 안 맞아서 동작 안 함
		for(int i=4;i<=n;i++){
			dp[i]=Math.max(dp[i-2],dp[i-3]+stairs[i-1])+stairs[i];
		}
		System.out.println(dp[n]);
	}
}
```