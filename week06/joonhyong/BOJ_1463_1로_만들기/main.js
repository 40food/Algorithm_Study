// 백준 1463번 1로 만들기
// 분류 : 다이나믹 프로그래밍
/*입력예제
10
*/
/*유도코드
- Top-Down 방식에서 x가 10인 경우는  두가지의 연산으로 시작할 수 있음
1. 2로 나눠 5로 만들고, 5에서 1로 만드는 방법
2. 1을 빼서 9로 만들고, 9에서 1로 만드는 방법 
- 이때, 9에서 1로 가는 방법과 5에서 1로 가는 방법 중 연산의 수가 더 적은 것을 고르면 됨
- 다만 Top-Down 방식에서는 9와 5에서 각각의 연산의 수를 구해야하는데,
- 그 과정 속에서 또 경우가 나뉠 수 있다.

- Bottom-Up 방식에서 x가 10인 경우는 두가지의 경우 중 한가지를 고르면 됨
1. 5에서 2을 곱하여 10에 도착
2. 9에서 1을 더하여 10에 도착
- 이때, 1에서 5로 가는 방법과 1에서 9로 가는 방법 중 더 연산의 수가 더 적은 것을 고르면 됨
- 1에서 1로 가는데 필요한 연산의 수는 0이므로, 최소 연산의 수를 하나씩 채워나간 후에 마지막 수 x에 도착했을때 고르기만 하면됨

*/
/* 알게된 점
- 메모이제이션 : 과정을 배열에 담아놓고, 필요할 때 마다 배열의 저장해놓은 요소를 이용하여 마지막에 도달
- 문제에서 주어진 상황에 반대로 시도해보는 것도 필요함
*/
const fs = require("fs");
const file = process.platform === "linux" ? "/dev/stdin" : "../exam.txt";
const input = fs.readFileSync(file).toString().trim().split("\n");

const x = parseInt(input);
const dp = Array(x + 1).fill(0);

dp[1] = 0;
for (let i = 2; i <= x; i++) {
  // dp[i-1]는 dp[i]에서 1을 빼는 연산을 수행한 것과 같으므로.
  dp[i] = dp[i - 1] + 1;

  // i가 2로 나누어 떨어지는 경우,
  // 1부터 i를 2로 나눈 값까지 연산한 수와
  // 1부터 i를 1로 뺀 값까지 연산의 수 중
  // 더 적은 것을 dp[i]에 적재
  if (i % 2 === 0) {
    dp[i] = Math.min(dp[i / 2] + 1, dp[i - 1] + 1);
  }
  // i가 3으로 나누어 떨어지는 경우,
  // 1부터 i를 3으로 나눈 값까지 연산한 수와
  // 1부터 i를 1로 뺀 값까지 연산의 수 중
  // 더 적은 것을 dp[i]에 적재
  if (i % 3 === 0) {
    dp[i] = Math.min(dp[i / 3] + 1, dp[i - 1] + 1);
  }
}
// for문이 끝나면 x+1번째 인덱스까지 수가 채워진 것임
console.log(dp[x]);
