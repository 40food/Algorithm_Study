메모리:<br>
시간: 

# 풀이
## 접근
큰 문제를 작은 문제로 나누어 푸는 동적 계획법 같다고 생각.

...했는데 아무리 생각해도 점화식을 모르겠다. DP는 아니었다.<br>
완전 탐색+문자열 처리 문제로 생각하고 접근.<br>
1. 1부터 문자열 길이의 1/2가 되는 시점까지 반복
2. 문자열 길이를 늘려가며 연속 반복된 구간을 세고 압축 결과 계산

## 구현
```java
public int solution(String s){
    	int answer=Integer.MAX_VALUE;
    	
    	for(int i=1;i<s.length()/2;i++) {
    		String prev=s.substring(0,i);
    		int j=i;
    		int count=0;
    		while(j<s.length()/2) {
    			String temp=s.substring(j, j+i);
    			if(temp.equals(prev)) count++;
    			j+=i;
    		}
    	}
        return answer;
    }
```
이렇게 prev를 잘라놓고, count를 세며 반복되는 걸 찾고, 반복문을 하나 더 넣어서 만든다는 건 알았는데 그 다음 구현에서 막힘.

## 문제점
### 개선판