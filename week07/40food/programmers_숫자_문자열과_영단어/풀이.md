메모리: 최대 90.1MB<br>
시간: 최대 0.27ms

# 풀이

## 접근

1. 문자열을 받고 이를 split해서 한 글자씩 읽는다.
2. 문자에 해당하는 글자일 경우 숫자로 변환해 배열에 넣는다.
3. 숫자에 해당하는 글자일 경우 그냥 배열에 넣는다.
4. 완성된 배열을 붙여서 출력한다.

## 구현

1. 들어온 글자에 compareTo를 사용해 0보다 크고 9보다 작으면 숫자로 판단해 parse int하여 list에 추가
2. 아니면 글자라는 것이므로 switch case를 통해 경우를 나눠 해당하는 숫자를 list에 add
3. i를 해당하는 글자 수만큼 증가시켜 나머지 글자 skip
4. 그렇게 만들어진 list를 돌면서 answer\*10을 하고 글자 add하여 answer 완성

## 문제점

- 왜 안 돌아가나 했더니 글자 비교는 `==`이 아니라 `equals()`임.
- 너무... 하드 코딩임.

### 개선판

```java
class Solution {
    public int solution(String s) {
        int answer = 0;
        String[] num = {"zero","one","two","three","four","five","six","seven","eight","nine"};
        for(int i=0;i<10;i++){
            s=s.replace(num[i],Integer.toString(i));
        }
        answer = Integer.parseInt(s);
        return answer;
    }
}
```

하드코딩이 빠르긴 더 빠르지 않을까 생각했는데 수천~수만 자 이상일 때만 유의미한 차이가 있고 그 외엔 replace면 충분함. (JVM에서 충분히 최적화되어 있어서)

물론 새 문자열 생성 비용이 누적되기 때문에 문자열이 길어지면 하드코딩이 효율적임.
