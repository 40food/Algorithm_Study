메모리: 20952KB<br>
시간: 228ms

# 풀이
## 접근
1. dfs로 진입
2. 4방향 체크를 진행해서 진행
3. 청소가 되지 않은 상태면 청소를 하고 1로 변경
4. 4방향이 다 1이면 종료

## 구현
```java
import java.util.*;

public class Main {

	static int count=0;
	static int[][] arrays;
	static int[] dr={-1,0,1,0};
	static int[] dc={0,1,0,-1};

	public static void main(String args[]) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt(); //행 수
		int m=sc.nextInt(); //열 수
		int r=sc.nextInt(); //행 위치
		int c=sc.nextInt(); //열 위치
		int d=sc.nextInt(); //보는 방향
		arrays=new int[n][m];

		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				arrays[i][j]=sc.nextInt();
			}
		}

		/* 접근
			1. dfs로 진입
			2. 4방향 체크를 진행해서 진행
			3. 청소가 되지 않은 상태면 청소를 하고 1로 변경
			4. 4방향이 다 1이면 종료
		* */

		dfs(r,c,d);
		System.out.println(count);
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				System.out.print(arrays[i][j]+" ");
			}
			System.out.println();
		}
	}

	public static void dfs(int r, int c, int d){
		if(arrays[r][c]==0){
			arrays[r][c]=1;
			count++;
		}
		//for문 4번 돌려서 방향 4개 앞의 값 체크
		for(int i=0;i<4;i++){
			int nr=r+dr[(d+i)%4];
			int nc=c+dc[(d+i)%4];
			if(arrays[nr][nc]==0) dfs(nr,nc,(d+i)%4);
		}
		//이 안에서 다음 방향으로 갈 수 있으면(0이면) 전진하고 dfs
		//다 1이면 종료
	}
}
```

평범하게 DFS를 하여 경로를 탐색했음<br>
근데 이러면 청소할 수 없는 부분까지 청소

## 문제점
1. (작은 실수...) (d+i)%4로 방향 전환을 해야하는데 d+i%4로 방향 전환해서 out of bound 뜸
2. 왼쪽으로 90도 돌아야하는데 해당 코드는 오른쪽으로 90도 돌고 있음
    - 그렇다고 dr, dc의 방향을 바꾸는 건 아님! 0북 1동 2남 3서는 유지하는 게 편함.
    - 그럼 d를 왼쪽방향으로 가도록 갱신할 필요o > `d=(d+3)%4`
    - 여기서 d 자체를 갱신해서 장애물이 있으면 다음 방향을 보도록 해야함
3. 후진 로직이 없음
    - 위의 코드는 막혔으면 돌아와서 다른 길을 탐색하는 전형적인 DFS인데 이러면 모든 길을 다 탐색해버림
    - `한 칸 갔으면 끝내버리고 돌아오는 건 후진 로직에 의존`하도록 구현해야 함
    - 돌아올 때 방향은 그대로 가져올 것

## 개선판
